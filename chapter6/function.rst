基本的な通信関連関数
=================

* 直接通信は行わないもののネットワークプログラミングにおいて重要である要素や、バイトオーダーなどの忘れがちな点をまとめて紹介する

ノンブロッキングモード
-------------------

* ソケットは通常ブロッキングモードになっており、ソケット入出力システムコールは何らかの処理を行う準備が整うまで制御を返さない
* 以下の用途のためにソケットがブロッキングを行わない「ノンブロッキングモード」が用意されている
    * シングルスレッドでプログラムを記述したい
    * データが取得可能を調べるだけのためにシステムコールを使いたい
* Linuxでは、ioctl()システムコールにFIONBIOを渡すことで、ブロッキング/ノンブロッキングの設定を行うことができる

エンディアンとネットワークバイトオーダー
----------------------------------

* エンディアン
    * バイトのメモリ配置方法の代表
        * ビッグエンディアン: 大きな桁を表すビットから最初に並べる方式（SUNのSPARCなど、2010年の時点）
        * リトルエンディアン: 小さな桁を表すビットから最初に並べる方式（Intel x86系CPU、2010年の時点）
    * ビット列のうち最も大きな桁を表すビット: MSB(Most Significant Bit)
    * ビット列のうち最も小さな桁を表すビット: LSB(Least Significant Bit)

* バイトオーダー
    * ビックエンディアンやリトルエンディアンのようなビットの並び
    * Linuxが自分のシステムで扱っているバイトオーダーを知るには__BYTE_ORDERを利用

* ネットワークを介して異なるエンディアン同士の機器が通信を行うときにエンディアンが統一されていないと通信は成り立たない
* TCP/IPでは通信を行う際のエンディアンとしてビッグエンディアンを使うと規定
    * ネットワーク上で利用するビッグエンディアン: ネットワークバイトオーダー
    * ホスト内部で利用するもの: ホストバイトオーダー
* POSIXでは、ホストバイトオーダーとネットワークバイトオーダーを変換する関数が規定されている（エンディアン変換関数）
    * htons()などは、エンディアン変換の関数
        * 数値や構造体、int 32,16はエンディアン考慮
        * charの配列は8ビットなので影響を受けない
* 最近はバイナリでの通信フォーマットではなく、HTTPやHTTP上でのXMLなどによる通信が増えてきており、これらは主に文字列でのデータ送受信を行うため、エンディアンの存在を気にせずにプログラムをかける環境が増えてきているかもしれない

ソケットの設定を取得
------------------

setsockopt()
^^^^^^^^^^^^^^
* ソケットに対する設定を行うシステムコール
    * setsockopt()を利用すると様々な設定が可能(appendix.rst->setsockopt()->設定内容)
        * ソケットをノンブロッキングにしたり、epollなどを利用しなくてもシステムコールをタイムアウトさせることができる
        * タイムアウト時間はtimeval構造体で指定(appendix.rst->timeval構造体)
* (appendix.rst->setsockopt())

getsockopt()
^^^^^^^^^^^^^^
* ソケットの設定内容を取得するシステムコール
* (appendix.rst->getsockopt())

getsockname()
^^^^^^^^^^^^^^
* ソケットに付いている名前を取得するシステムコール
* 使いどころ
    * connect()が成功した後にピア側（相手側）ではなく、自分側のポート番号を知るとき
    * bind()を行わずにlisten()を行った時に自動的に割り振られたポート番号を知るとき
* (appendix.rst->getsockname())

getpeername()
^^^^^^^^^^^^^^
* ソケットに接続されたピア側（相手側）に関する情報を取得するシステムコール
* (appendix.rst->getpeername())

シグナルハンドリング
-----------------

* 以下のブロッキングするシステムコールは実行中にシグナルを受けて割り込みが発生すると、エラーで終了し、errnoにEINTRが設定される
    * read()
    * write()
    * recv()
    * send()
    * recvfrom()
    * send()など
* シグナルを活用してプロセス外からの制御を行うようなプロセスを実装するときに、これらのシステムコールのエラ処理内でEINTRを考慮する必要がある

知っておくと便利なマクロ
-----------------

''/usr/include/netinet/in.h''
    * IPv4/IPv6アドレスの判定や比較用のマクロが宣言されている
    * IN_MULTICAST(a)を利用すると、IPv4アドレスがマルチキャストアドレスかどうかを確認できる


引用
あきみち，”基礎と実装Linuxネットワークプログラミング”，株式会社品の出版，2010，pp.166-186