プロセス間通信
=============

* プロセスは、それぞれ固有の仮想アドレス空間を持つことで、外部からの干渉を防ぎ、独立した動作ができるように設計されている
* しかし、すべてを防ぐだけでは他のプロセスと協調できなくなってしまうため、以下の場合などでは「プロセス間通信」が必要
    * 複数のプロセス間で何らかの作業を共有
    * 複数のプロセス間で進行状況を同期
* 一般的なプロセス間通信の手法
    1. シグナル
    2. UXITソケット
    3. ソケットペア
    4. パイプ
    5. 共有メモリ
    6. セマフォ
    7. メッセージキュー


1. シグナル
-----------

* プロセスの外部から、何らかのイベント通知を行う仕組み
* 任意のタイミングで送信することが可能
* kill()
    * ユーザからプロセスに対してシグナルを送るシステムコール
* シグナルハンドラ
    * シグナルを受け取ったときの挙動を指定するには、シグナルハンドラを登録する必要がある
    * signal()（appendix.rst->signal()）
        * シグナルハンドラを登録するシステムコール
    * シグナルハンドラが登録されていないシグナルを受け取ったときのデフォルト動作は、シグナルの種類によって異なる
    * 各シグナルにおけるデフォルト動作の確認
        * ``man 7 signal``

2. UNIXソケット
------------

* システム内でソケットを利用した通信を行うためによく利用される
* AF_UNIXアドレスファミリ（AF_LOCALという別名もある）
* 信頼性のあるSOCK_STREAMと、データグラム型のSOCK_DGRAMをソケットタイプとして利用可能
* 通信の識別を行う一意性を持つ識別子としてファイル名(ファイルパス)を利用する

3. ソケットペア
------------

* UNIXソケットを利用するにはファイルシステムを利用する必要がある
* サーバ側とクライアント側で別々にlisten()やconnect()を行わなければならず、手間がかかる
* socketpair()（appendix.rst->socketpair()）
    * ファイルシステムを介さずに2つのソケットの口を得るときに便利なシステムコール
* Linuxではsocketpair()システムコールはAF_UNIX（AF_LOCAL）しかサポートされていない
* ソケットペアを利用すると、2つの異なるプロセス同士が全二重の通信を行うことができる

4. パイプ
----------

* pipe()（appendix.rst->pipe()）
    * 名前を必要としないファイルディスクリプタのペアを生成する方法
    * pipe()によって生成されるパイプはソケットペアと似ているが、ソケットではない点と片方向である点が異なる


System V IPC
--------------

* Linuxには「System V IPC」プロセス間通信用の機能群
    * 共有メモリ
    * セマフォ
    * メッセージキュー
* 相互に親子関係がないプロセス同士でも通信が可能な仕組みになっている
* ソケットやパイプとは違い、System V IPCはプロセスとは独立した形でシステム内に確保される
* 一度作成されたSystem V IPC資源は、明示的に開放されるか、システムが停止するまで確保され続ける

* IPC資源とIPCキー
    * 各プロセスは、IPCキーを利用してIPC資源（共有メモリ、セマフォ、メッセージキュー）にアクセスする 
    * 各プロセスは、同一のIPCキーを利用することで同じIPC資源にアクセスできる
    * ソケットやパイプなどを表現するファイルディスクリプタはプロセス内で一意であり、別プロセスで同じ値を利用可能
* ftok()（appendix.rst->ftok()）
    * ファイルパスを利用してIPCキーを生成するための関数
    * ftok()による結果が一意であることは保障されていないので、衝突することも想定して利用すべき
* IPC資源を管理するためのコマンド
    * ipcs: IPC資源に関しての情報を表示
    * ipcrm: IPC資源を解放（削除）するためのもの

5. 共有メモリ
^^^^^^^^^^^^

    * 記憶領域を共有するためのもの
    * 複数のプロセス間で同時に同じメモリ空間にアクセスすることができる
    * プロセス間でもメモリを直接共有する機構であるため、ソケットなどを介したプロセス間通信と比べて、非常に早いデーテ転送を実現できる 
    * shmget() （appendix.rst->shmget()）
        * 共有メモリ取得用システムコール
    * shmat()/shmdt()（appendix.rst->shmat()/shmdt()）
        * 共有メモリの操作
    * shmctl() （appendix.rst->shmctl()）
        * 共有メモリ資源の解放
    * クリティカルな領域に関しては複数のプロセス間で同期を取りながらメモリへの読み書きを行わなければならない

6. セマフォ
^^^^^^^^^^^^

    * 複数のプロセス間で同期を取るための仕組み
    * 複数プロセスで共有メモリへの書込みや読み出しタイミングを合わせる場合などに利用可能
    * セマフォを利用するには、IPCキーを利用してセマフォ識別子を取得する
    * semget()  （appendix.rst->semget()）
        * セマフォ識別子取得用システムコール
        * 利用するときの注意点: semget()で作成されたセマフォが未初期化状態であること
            * アプリケーションは、semget()によって作成されたセマフォ識別子で表現されるセマフォセット中の各セマフォ値を各自で初期化する必要がある
    * semctl() （appendix.rst->semtl()）
        * セマフォを初期化したり解放するシステムコール
    * semop() （appendix.rst->semop()）
        * セマフォの操作
        * sembuf構造体に含まれる情報に応じた操作(appendix.rst->sembuf構造体）
        * この操作は他の処理が同時に走って不定になることがなく、操作内で何らかの失敗があると状態は実行前に戻される

7. メッセージキュー
^^^^^^^^^^^^^^^^^^

    * Queue構造をしたメッセージ配送システム
    * プロセスはメッセジーキューを利用してメッセージのやり取りを行うことができる
    * メッセージキューはFIFOのQueue構造になっている
        * プロセスがメッセージキューからメッセージを取り出すと、そのメッセージをQueueから消える
        * ひとつのメッセージが複数のプロセスに渡されることはない
    * msgget() （appendix.rst->msgget()）
        * メッセージキューの作成、もしくは既存メッセージキュー識別子をIPCキーから得るシステムコール
    * msgctl() （appendix.rst->msgctl()）
        * メッセージキューを解放するシステムコール


引用
あきみち，”基礎と実装Linuxネットワークプログラミング”，株式会社品の出版，2010，pp.193-230.